---
#! bootstrapping: first we make a selfsigning issuer
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
  name: selfsigning-issuer
  namespace: {{ .Release.Namespace }}
spec:
  selfSigned: {}

---
#! then we use that to generate a CA, storing that in cf-system-root-ca
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: cf-system-root-ca
  namespace: {{ .Release.Namespace }}
spec:
  secretName: cf-system-root-ca
  dnsNames:
    - cf-system-root-ca
  isCA: true
  issuerRef:
    name: selfsigning-issuer
---
#! then we make a CA issuer from that self-signed CA
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
  name: cf-system-ca-issuer
  namespace: {{ .Release.Namespace }}
spec:
  ca:
    secretName: cf-system-root-ca

---
#! components can use that issuer to generate internal server certs
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: cc-server-tls
  namespace: {{ .Release.Namespace }}
spec:
  secretName: cc-server-tls
  dnsNames:
    - capi.{{ .Release.Namespace }}.svc.cluster.local
  issuerRef:
    name: cf-system-ca-issuer

---
#! as well as client certs for mtls
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: cc-client-tls
  namespace: {{ .Release.Namespace }}
spec:
  secretName: cc-client-tls
  dnsNames:
    - capi-client
  usages:
    - client auth
  issuerRef:
    name: cf-system-ca-issuer

---
#! if we make kapp responsible for versioning the underlying secrets
#! it can also handle rolling pods that mount these certificates
apiVersion: v1
kind: Secret
metadata:
  name: cc-server-tls
  annotations:
    kapp.k14s.io/versioned: ""
type: "kubernetes.io/tls"
#! removing "data" here will leave these certs alone
#! empty fields here will regeneration trigger controlled rollout
data:
  tls.key:
  tls.crt:

---
apiVersion: v1
kind: Secret
metadata:
  name: cc-client-tls
  annotations:
    kapp.k14s.io/versioned: ""
type: "kubernetes.io/tls"
data:
  tls.key:
  tls.crt:
